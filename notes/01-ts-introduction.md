# TypeScript

##

#### typescript introduction

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * TypeScript           // 2012 年 微软( Anders HejLsberg 开发 )发布 
 * 
 * 
 * ts 是 js 的超集，是一个可选的，静态的类类型系统
 * 
 ** 有了 ts 的类型检查，增强了面向对象的开发
 */


        + ------- TypeScript ------ +               // 超集
        |                           |
        |   + ------ ES6 ------ +   |               // 
        |   |                   |   |
        |   |   + -- ES5 -- +   |   |               // 
        |   |   |           |   |   |
        |   |   |           |   |   |
        |   |   + --------- +   |   |
        |   |                   |   |
        |   + ----------------- +   |
        |                           |
        + ------------------------- +


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


类型系统: 对代码中所有的标识符( 变量，函数，参数，返回值 )进行类型检查

可选的: 

静态的: 类型检查发生在编译的时候，并非发生在运行时


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


无论是 "浏览器环境/node环境"，都无法直接识别 ts 代码

    babel: es6 -> es5
    
    tsc: ts -> es


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```     

#### install typescript

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * ts
 * 
 * 
 * 
 */

npm i -g typescript            // 全局安装 ts & ts cli


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### ts config

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 默认情况下，TS 会作出以下假设
 * 
 * 
 * 1) 使用 tsc cli 时，增加参数可改变以下假设
 * 2) 使用 ts 配置文件，更改编译配置                     // 建议使用
 */

1) 假设当前的执行环境是 DOM

2) 若代码中未使用模块化语句( import, export... )，则假设该代码未全局执行

3) 编译的目标代码为 ES3


//-------------------------------------------------------------------------------------------------------------------//


/**
 * create tsconfig.json
 * 
 * 
 * 使用 tscconfig.json 后，在使用 tsc-cli 编译时，不能跟上文件名，否则会忽略 配置文件
 * ( 直接使用 tsc 即可，不要使用 tsc target.ts )
 */


1) 手动创建 tsconfig.json

2) tsc-cli: tsc --init


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * @types/script
 * 
 * 
 * @types 是一个 ts 的官方类型库，其中包含了很多对 js 代码的类型描述
 */

eg:

    @types/node
    @types/jquery


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * ts-node_cli
 * 
 * 
 * 将 ts 代码在内存中完成编译，同时完成运行
 */

npm i -D/-g ts-node


/**
 * nodemon
 * 
 * 
 * 监测 ts 文件变化
 */

npm i -g nodemon

nodemon --watch [dir] -e [extension] --exec [Statement]


eg:

nodemon --watch example -e ts --exec ts-node index.ts


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


{
    "compilerOptions": { 
    
        "target": "es5",                // 配置编译目标代码的版本标准
        "module": "commonjs",           // 配置编译目标使用的模块化标准
        "outDir": "dist",               // 配置编译结果输出目录
        "strictNullChecks": true,       // 空类型检查( null & undefined )
        
        "modle": "ES2015",              // 设置编译结果中使用的模块化标准
        "moduleResoletion": true,       // 设置解析模块的模式
        "noImplicitUseStrict": true,    // 编译结果中不包含 "use strict"
        "removeComments": true,         // 编译结果移除注释
        "noEmitOnError": true,          // 错误时不生成编译结果
        "esModuleIInterop": true,       // 启用 es模块化交互 非es模块导出
        
    },
    "include": [                        // 指定编译目录
    
        "./dir"
    ],
    files: [                            // 指定编译文件
    
        "./dir/file.ts"
    ]
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### react + ts

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * react + typescript
 * 
 * 
 * 1) webpack
 * 2) dva, umjs, nextjs, create-react-app
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// create-react-app

github -> create-react-app -> doc.add-typescript.md


// 编译过程

webpack -> ts -> js -> babel -> res


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//




///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```


##

#### enumerate-type

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 枚举类型         // 最终以 对象的形式 出现在编译结果中
 * 
 * 
 * 枚举通常用于约束某个变量的取值范围        // 字面量和联合类型配合使用，也可以达到同样的效果
 */

// 最佳实践:

    - 枚举中 不要同时使用 字符串 和 数字
    
    - 使用枚举时，避免使用真实的固定值( 该使用 枚举的属性值，保证数据的可变性 )


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 枚举类型 vs 别名


枚举类型:

    - 枚举的代码最终会以 对象的形式 出现在编译结果中

    - 枚举

别名:

    -
    
    -


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 字面量和联合类型配置使用中存在的问题

1) 在类型约束位置，会产生重复代码( 可以使用类型别名解决该问题 )

2) "逻辑含义" 和 真实的值 产生了混淆，导致当修改真实值时，产生大量修改( 需要修改工程中多处 )

3) 字面量类型不会进入到编译结果中( ts仅在开发阶段有效，实际编译用的是转译后的 js )


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//
 

// 枚举

1) [real_val]: string | number;

2) [real_val]: number; 时，[real_val] 会根据 [first_real_val] 自增

3) [real_val]: number; 被数字枚举约束的变量，可以直接赋值为数字

4) [real_val]: number; 数字枚举的编译结果比较特殊


// ts

    enum Level {
    
        level_01,
        level_02,
        level_03
    }
        
    let lv: Level = Level.level_01;
    lv = Level.leve_02;
    console.log(lv);


// js

    var Level;

    (function(Level){
    
        Level[Level["level_01"] = 0] = "level_01";
        Level[Level["level_02"] = 0] = "level_02";
        Level[Level["level_03"] = 0] = "level_03";
    
    })( Level || (Level = {}) );
    
    let lv = Level.level_01;
    lv = Level.level_02
    console.log(lv);
    
    
    {
        level_01: 0,
        level_02: 1,
        level_03: 2,
        0: "level_01",
        1: "level_02",
        2: "level_03",
    }


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// syntax

enum [name] {

    [key]: [real_val],
    [key]: [real_val],
}


eg:

enum Gender {

    male: '男',
    female: '女'
};

gender = Gender.male;               // '男'


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

##

#### ts-modules

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * ts modules           // ts 支持 ES6 模块化标准
 * 
 * 
 * 模块化标准: ES6, commonjs, amd, umd, system, esnext ....
 */

ts 优先 es6 模块化标准!
ts 优先 es6 模块化标准!
ts 优先 es6 模块化标准!

( ts 中的 commonjs 需要特殊处理 )


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### Module resolution strategy

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * Ts 中的两种模块解析策略
 * 
 * 
 ** 建议使用 node 解析策略
 */

- classic: 经典

- node: node解析策略( 唯一不同，原本是默认解析 .js，现在是默认优先解析 .ts )

     tsconfig: { "moduleResolution": "node" }                  


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

## Interface Type

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 接口类型             // ts 接口，用于于约束 "类，对象，函数" 的契约( 标准 )
 *                    // 和类型别名最大的区别在于 约束类
 * 
 * 
 * 扩展类型: 类型别名，枚举，接口，类
 */

契约( 标准 )形式

    - API 文档            // 弱标准
    - 代码 约束            // 强标准


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### class type

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * ts 中的 类
 * 
 * 
 * 
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### custom_type

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 
 * 
 * 
 * 
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```














