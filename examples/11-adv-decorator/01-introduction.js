///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
var _a;
/**
 * Problem: 某些信息在定义时，能够附加的信息量有限
 *
 *
 ** 装饰器: 为某些 ( 成员, 类, 参数 ... ) 提供元数据信息                  // js 中的装饰器 本质上是 函数
 *
 * @元数据: 用于描述数据的数据称为 元数据( meta data )
 */
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//
/**
 * decorator                // 增加额外的信息量，分离关注点
 *
 *
 * 1) 在创建某些 ( 成员, 类, 参数 ... ) 时，添加 该元数据 的描述( @decorator )
 *
 * 2) 后续调用统一的验证函数
 *
 *      - 利用已定义好的 元数据 及其 描述( @decorator )
 *
 *      - 再统一执行 "利用 [元数据的描述] 去验证 [元数据]"
 */
class UserDecorator {
}
const userDecorator = new UserDecorator();
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//
/**
 * 外部验证
 *
 *
 ** 导致每次创建用户都需要去验证
 */
// 对用户对象中的数据进行验证
if (userDecorator.loginId && userDecorator.loginId.length <= 5 && ((_a = userDecorator.loginId) === null || _a === void 0 ? void 0 : _a.length) >= 3) {
    // loginId 验证通过
}
else {
    // 抛出错误信息
}
// 进行其他属性验证
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//
/**
 * 虽然可以后续利用函数封装，统一约束 成员
 *
 *
 ** 但从思维逻辑的角度，此时已经 将关注点分离，不符合人的思维逻辑
 */
// 后续调用统一的验证函数
function validate(obj) {
    for (const key in obj) {
        const val = obj[key];
        // 缺少不同属性的验证规则
    }
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
